{"pages":[],"posts":[{"title":"On-Ramp","text":"背景现在数据中心网络的解决主要包含两类方式： 一类是 依赖于网络中日益丰富的拥塞信号（ECN、queue size、link utilization等） 一类是 关注数据包调度机制，通过对数据包进行调度避免拥塞的发生 近几年提出的算法越来越依赖于网络内部，比如依赖于网络拥塞的信号（rely heavily on rich congestion signals from network）或者是返回的网络的链路带宽、队列大小等复杂的信息，但是现在某些环境下并不能得到这些复杂的网络信号，比如公共云环境中，云用户可以访问网络的边缘，但是他们不能访问网络基础设施，那么他们就无法接收到拥塞控制信号或是调度机制，从而无法有效的进行拥塞控制。 本文要解决的问题：在network无法提供复杂的拥塞信号，也无法提供包调度支持的情况下，如何实现好性能 作者的思想与以往的算法有所不同，以往的算法如下图所示的公式来更新发送窗口和发送的速率，但这在瞬时（transient）和平均（equilibrium）状态下的权衡考虑有所欠缺，导致 Transience-Equilibrium Tension，即：在均衡状态下表现良好的参数在瞬时过载状态下的表现并不理想，反之亦然 在cc为Timely时，可以看到，当设定的β值符合equilibrium时（link fully utilized）transient 的性能不理想，反之，当transient理想时（排队延迟很快就下降，应对严重的暂态拥塞）equilibrium的性能又下降了。 在cc为DCQCN时，多次收敛。 所以本文将这两种网络状态解耦合，分开进行处理，提出On-Ramp，对均衡和瞬时的流量分别处理： 在均衡（equilibrium）状态下：使用现有的拥塞控制算法。（On-Ramp可以和任何数据中心拥塞控制算法结合，只需要修改终端主机而不需要修改交换机） 而在瞬时过载（transient overload）状态下：使用本文的新算法On-Ramp，On-Ramp在瞬时过载期间拦截并保存网络边缘的任何协议的数据包。 工作内容ON-Ramp核心思想On-Ramp是一种简单的端到端流控制算法，作为拥塞控制算法和网络之间的垫片；部署在sender和receiver之间的CC算法下（入口匝道） 当发送方的拥塞控制协议决定发送一个包时，如果最近确认的包的发送方到接收方的单向延迟（OWD）超过一个阈值T，则发送方会暂停发送数据包。即当 OWD的值超过阀值T时，通过暂停发送端的流使得路径队列延迟尽可能快的降低。当OWD没有超过T时，On-Ramp不起作用。 设计机制Receiver Side：收到Packert后，返回一个OR-ACK给sender，包含了，数据包序列号，收到数据包的时间，流量指示器（the flow indicator）。 Sneder Side：发送方为每个流维护两个数据结构： 属于该流的未发送数据包的队列 来自该条流的下一个包的传输时间 最初，tNextPkt被设置为0，在收到OR-ACK后，它被更新如下： 这里的现在是当前的系统时间 第一个方案简单而直观：当收到一个OWD值为O超过阈值T的OR-ACK时，暂停O−T。目标是将队列排空，这样暂停后的OWD就在T下。但是O-T是理想情况下的暂停时间，即返回的ACK在链路上没有任何的延迟，实际情况应该更复杂。=》问题1 假设发送方和接收方之间的路径之间只有一个交换机，传播时间可以忽略不计；因此，OWD基本上等于交换机中的排队时间。=》问题2 sender在发送数据的时候可能暂停一会才发送的情况，但是receiver收到packet时并不知道这个情况，依然把这一段时间看作是OWD值。然后返回给sender，假设暂停的时间是P，返回的OWD值是O，那么实际的单程延迟（OWD值）不是O，而是 O-P。 但是作者认为还要考虑其他发送端对暂停的影响。 代表black packet和green packet之间暂停的时间 sender暂停对OWD值的影响 当β接近1时，说明OWD值的减少与sender暂停时间的减少大致相同 β接近0时，说明On-Ramp必须暂停较长的时间才能降低OWD值（也就是black packet和green packet两者发送之间暂停的时间很长） On-Ramp为其传输的每个新包获得一个这样的βm测量。它用每个新的测量值来计算这些值的移动平均值。 问题1 O-T是理想情况下的暂停时间，即返回的ACK在链路上没有任何的延迟，实际情况应该更复杂 2 反馈延迟导致链路利用率低 3 只对瞬态有影响，有没有一种信号可以判断链路中出现了突发流，根据这种信号决定使不使用On-Ramp 4 多个发送端时，由长流引起的暂停导致短流一直无法发送 5 On-Ramp部署在拥塞控制算法之上，对长流的收敛没有影响，对于突发流可能在暂停恢复后造成链路利用率不足的情况， （1）如果是两条长流互相竞争造成的拥塞，那么发送端就会暂停并且减窗 （2）如果是一条长流和一个或多个突发短流互相竞争造成的拥塞，就不应该在暂停的同时减窗 所以不能够与拥塞控制算法完全解耦 ==》识别链路中的突发短流，缓解突发流带来的链路利用率不足的问题 ==》利用单项延迟变化的斜率来判断是否是突发流（某种关系），如果是突发流，就只暂停不减窗 问题：多瓶颈 下周任务：把问题做出来，找出单瓶颈状态下判断链路状态的方法 ==》owd斜率连续的趋势 描述响应概率 ==》暂停恢复后根据响应概率加减窗调整速率 【αβ】来描述响应概率 α表示倾斜程度的权重 β表示连续趋势次数的权重 做出问题 ![img](file:///C:\\Users\\18570\\Documents\\Tencent Files\\1264631479\\Image\\C2C\\B020{6ZZ%K9J{XP$[MHGP08.png)","link":"/2021/11/16/11.16On-Ramp/"},{"title":"MATCP","text":"背景微突发流量在数据中心并不少见。它可能导致数据包丢失，这可能导致严重的性能下降（例如，Incast问题）。 然而，目前缓解微突发的方法通常是临时的，而不是基于对底层行为的原则性理解。例如，减少RTOmin，限制并发流的数量并在应用层中增加抖动，在交换机缓冲区中吸收微突发，通过在源端口处调整数据包的速度来缓解微突发。 另一方面，传统的研究侧重于单个流中的流量突发性，而数据中心中的微突发流量可能以多输入端的通信模式出现，其动态行为难以弄清楚。 作者考虑到数据中心里网络流量的模式，研究了基于窗口的传输协议控制下的微突发流量。主要贡献总结在三个方面： （1）self-clocking和拥塞控制算法共同主导了微突发的变化 （2）在数据中心网络环境中，传统的机制（如吸收和调整）是无效的。从根本上讲，对于数据中心中对延迟敏感的短消息的传输，理想的解决方案是及时检测拥塞并尽快适当地限制发送速率。 （3）存在一个不变的变量（即队列长度演化的时间导数或斜率），可以精确描述大多数情况下微突发的动态行为。 工作内容MATCP观测方法对于通过交换机的每个数据包，我们让数据包在其有效负载中携带时间戳和当前队列长度。当数据包到达接收方时，接收方从中提取时间戳和队列长度，并将数据存储到磁盘中。实验结束后，收集数据进行进一步分析。【TPP， ACM SIGCOMM, 2014.】 观测结果当扇入流聚集在队列中时，队列长度演化可分为两个阶段：Non-clocked阶段和ACK-clocked阶段。在Non-clocked阶段，队列长度的增加是由第一轮数据包的到达引起的。Non-clocked阶段队列长度演化的斜率直接反映了通信模式（如同步或异步）和强度（如扇入度）。具体来说，使用同步通信和更多并发流，此阶段的斜率更高。 在ACK-clocked阶段，到达流量受瓶颈容量限制。 在不同的网络场景下，各种情况的微突发： 1）同步扇入流 2）异步扇入流 3）具有一个背景流的扇入流 4）具有多个背景流的扇入流 5）前一跳时有多个背景流拥挤的扇入流 斜率在网络中可以总结为以下三个规律： 在没有背景流的情况下，ACK-clocked阶段的斜率等于瓶颈容量 当某些背景流在同一跳上拥塞时，ACK-clocked阶段的斜率小于瓶颈容量 在前一跳有多个背景流拥塞的情况下，ACK-clocked阶段的斜率可能大于瓶颈容量，但不大于2R，R即瓶颈容量。 传统的机制（如吸收和调整）是无效的。 TCP pacing不够强大 ECN标记法： 这种基于队列长度的ECN标记的响应不足以抑制队列长度的急剧增加，因为直到队列长度达到阈值时才标记数据包。此外，在队列长度达到阈值后，所有发送方都需要时间才能接收来自交换机的反馈。在此期间，队列长度仍在急剧增加，在所有发送方减速之前，缓冲区可能会溢出。 斜率直接反映了聚合流量的突发程度。具体地说，ACK-clocked阶段的斜率反映了流的并发性，反映了发送速率和瓶颈容量之间的不匹配。 通过根据斜率小心地减慢发送者的速度，可以有效地抑制微突发引起的队列长度急剧增加。 核心思想微突发感知传输控制协议(MATCP),利用队列长度演变的斜率作为检测拥塞的指标，来预测队列长度演化，因为斜率（在ACK时钟阶段）非常稳定。 发送方可以在队列长度达到ECN阈值之前根据斜率适当减速。 设计机制 发送方可以在队列长度达到ECN阈值之前根据斜率适当减速。 switch：MATCP交换机负责将坡度反馈给发送方。交换机有两个功能：更新斜率和将斜率注入通过交换机的数据包中。 在MATCP中，我们使用两种方法来适应队列长度抖动： （1）在计算斜率时，我们使用平均队列长度而不是瞬时队列长度。平均队列长度通过指数加权移动平均（EWMA）计算 （2）以RTT的粒度更新斜率 只有当交换机的斜率大于数据包携带的斜率时，交换机才会将斜率注入数据包。 接收端：接收数据包时，接收端从包头提取斜率。当准备发送ACK时，接收端将最近的斜率放入报头。 发送端：接收ACK数据包时，发送方从数据包头提取斜率。在接收任何ECN信号之前，MATCP发送方利用斜率来降低发送速率。接收到ECN信号后，斜率无用。降低速率的策略 假设交换机在时间t0反馈斜率，发送端在时间t1接收斜率，估计t1时刻的队列长度为 ： d表示有排队延迟的往返时间，d0表示不排队的往返时间 假设有N个发送端，Wi(t)表示发送端i在时间t时的拥塞窗口大小，如果 t1时刻，发送端会减少他的窗口大小， 在所有发送方减速后，队列长度返回到交换机反馈斜率时的值。 因此，将拥塞窗口切割为可以有效地抑制队列长度的急剧增加，而不会导致缓冲区下溢。 会议版： 只统计了规定的场景下五种扇入流对应的斜率形状，没有找出队列长度斜率变化对应的链路拥塞情况。 期刊版： For example, when fan-in ﬂows start synchronously,bursts from diﬀerent ﬂows may arrive simultaneously.As a result, there are impulses during queue length in-creasing (Figure 2(a)). When fan-in ﬂows start asyn-chronously, bursts from diﬀerent ﬂows may arrive separately. As a result, queue length increases in a smoother way (Figure 2(b)). Besides, queue length evolution is also diﬀerent when there are background ﬂows. Moreover, as depicted in Figure 2(a), slope of queue increasing (i.e., queue length increasing rate) can reﬂect the fan-in degree, since with more concurrent ﬂows the queue length tends to increase faster","link":"/2021/11/23/11.23MATCP/"},{"title":"同步TCP","text":"背景改变基于路由器的拥塞控制AQM 提出了一种端到端的AQM替代方案– 一种基于TCP连接中TCP段单向传输时间测量的新的TCP拥塞检测和反应机制。 核心思想在TCP报头中放置时间戳，测量单向传输时间的变化，并使用这些测量作为早期拥塞通知的一种形式。因为路由器中的队列在溢出之前就已经建立起来，导致OTT增加。如果发送方直接测量OTT的变化，并在OTT增加表明发生拥塞时退出，拥塞可能会得到缓解。 设计机制 （1）此TCP报头选项包括为接收到的最后一段（OTT）计算的OTT（微秒）、当前段的发送时间（时间戳）和接收到的最后一段的发送时间（回复）。当接收器看到任何具有同步TCP时间戳选项的段时，它通过从接收段的时间减去发送段的时间来计算该段的OTT。然后将OTT插入接收机发送给发送方的下一段（通常为ACK）。在接收到ACK时，发送方可以通过从ACK中存在的OTT减去其最小观测OTT来估计当前排队延迟。 （2）同步TCP发送方为接收到的每个ACK获取新的队列延迟估计。对这些排队延迟进行平均，并确定平均排队延迟的趋势。 趋势分析算法基于Jain和Dovrolis[13]的算法 使用九个ack 平均排队延迟样本进行趋势分析，将九个样本分成三组，按照他们的顺序，每组三个样本。每一组取出它的中位数mi。然后按顺序m0&lt;m2，则认为趋势为增长；m0&gt;m2。则认为趋势为减少。 每三个ACK计算一个新的趋势。每次接收到ACK时，同步TCP中的拥塞检测机制都会报告两种结果之一：（1）没有收集足够的样本来计算趋势 （2）收集了足够的样本，报告了平均排队延迟与观测到的最大排队延迟之间的关系以及趋势的方向。 斜率连续的趋势 =》响应概率 暂停恢复根据响应概率加减窗调整速率 根据斜率来调整窗口大小尽量避免拥塞 如何根据斜率判断突发流","link":"/2021/11/29/11.29+7%E5%90%8C%E6%AD%A5TCP/"},{"title":"RotorNet","text":"背景现代数据中心不断增长的带宽需求促使研究人员提出了基于光电路交换机的网络，但这些方案面临着重大的部署挑战。特别是，以前的提案动态配置电路交换机以响应工作负载的变化，需要网络范围的需求估计、集中的电路分配和各种网络元素之间的时间同步，从而导致复杂而笨拙的控制平面。此外，单个电路交换机背后的技术限制了它们可以重新配置的速率和可以构建的网络规模；有必要采取新的办法。 加州大学圣地亚哥分校的研究人员设计了一种称为RotorNet的新解决方案，这是一种基于电路的网络设计，旨在克服上述限制。当RotorNet动态地重新配置其组成电路交换机时，它将交换机配置与流量模式分离。在物理层，RotorNet放松了对底层电路交换机的要求，特别是不要求单个交换机实现一个完整的交叉开关，从而使它们能够扩展到1000个端口。RotorNet在各种工作负载条件下，包括从两个商业数据中心获取的跟踪，都优于价格相当的胖树拓扑。我们还演示了在八节点试验台上实际运行的小型RotorNet。 本文的贡献包括： 1）避免闭环电路调度的光交换网络的设计方向 2）开环Rotor switch和由这些交换机构成的数据中心范围的结构 RotorNet 3）对RotorNet的分析表明，它支持在全二分法带宽下的统一流量，半等分带宽的最坏情况（置换）流量，以及报告的商业数据中心流量，以较低的成本获得理想胖树网络70–90%的带宽 4）原型硬件上RotorNet的VLB类路由算法的演示和评估 分组交换机的folded-Clos 网络 在折叠clos网络结构中，终端主机基本上与构成网络核心的包交换机解耦。服务器可以将数据发送到任何目的地，而fabric无需与发送方进行进一步通信就可以交付该数据。每个分组交换器都有内部缓冲以吸收突发，以及以线路速率通过交换机传送流量的机制。发送方可能收到的交换机供应不足的唯一信号是包丢失或ECN标记当提供给交换机的负载超过一个或多个传出链路的容量时;在这种情况下，传输协议(如TCP)降低发送速率以收敛到一个可接受的需求。 每个设计都试图将网络配置与当前或未来的流量需求相匹配，以最大限度地提高总体网络吞吐量，这需要一个复杂的数据中心范围的控制平面，但很难扩展。 电路交换机的网络结构 最近基于ocs的建议从根本上改变了交换机控制平面的性质。为了最大限度地提高吞吐量，动态地重新配置网络拓扑以响应观测或预测的流量的建议必须执行与上面所示的电子分组交换机相同的任务。然而，虽然分组交换机能够将其内部管理过程隐藏在离散的盒子中，但以前基于ocs的拓扑由于无法缓冲和检查分组，将这种控制复杂性暴露给整个网络，将网络结构变成一个巨大的耦合交叉栏。不需要统一的需求调度或集中的控制器。每个交换机根据预先确定的一组配置独立旋转。 设计机制开环交换与之前的光交换网络方案不同，转子开关的配置不受本地或全局网络流量条件的驱动。在RotorNet中，转子开关以循环方式独立地通过一个固定的、预先确定的连接模式循环，而不考虑瞬时流量需求。我们选择转子开关配置的时间序列(每个都是输入到输出端口的一对一匹配，或者只是一个“匹配”)，以便在一个完整的匹配周期内，为每个端点(即ToR)提供与其他端点的直接连接。 图3演示了这种方法，显示了三个匹配的两个完整循环。我们强调了顶部端口的连接性变化，因为它在不同时间内通过匹配将其连接到第二、第三和第四端口。 因为这种方法将交换机状态与网络中的流量解耦，它不需要需求收集，不需要交换机调度算法，也不需要网络范围内的同步。开关简单地运行“开环”。 作为第一次切割（匹配结束），每个NR端口转子开关可以重复循环通过所有NR!可能匹配，对应于交叉开关提供的全部潜在匹配。然而，对于大的NR来说，完成这个循环需要相当长的时间，而且我们不能保证在任何合理的时间内完成给定的连接。此外，只需(NR−1)匹配即可确保所有NR tor之间的连接。 对于NR=8，图4(a)显示了这些匹配的示例集。通过这些(NR−1)匹配，可以保证每个ToR在一个匹配周期内都连接到其他ToR。这种功能类似于转子设备。 然而，对于具有许多tor的网络，即使是(NR−1)匹配的循环仍然需要很长时间。相反，如图4(b)所示，我们将(NR−1)匹配分配给Nsw个并联 Rotor switch，将匹配周期时间提高了一个Nsw因子。 单跳直接转发 鉴于Rotor交换机提供的基线轮循连接，每个ToR必须决定如何在网络上路由流量。对于tor来说，最简单的方法是只沿单跳的直接路径发送数据到每个目的地，从而导致每个源目的地对之间的带宽相等。对于均匀流量，这种行为会导致吞吐量饱和网络的平分带宽(减去交换机占空比)，并且从本质上来说是没有饥饿（链路利用率不足）的。然而，对于倾斜的流量模式，当一些tor空闲时，这种方法不能利用松弛的网络容量，从而可能浪费大量的带宽。 两跳间接转发 允许流量通过中间端点，中间端点随后将流量转发到最终目的地。 RotorLB 在将新的间接流量发送到网络之前，RotorLB对存储的非本地流量(在其第二跳上)和可以直接发送到当前槽中的目的地的本地流量进行优先级分配。使用该槽中的任何剩余链路容量 允许来自同一流的流量通过 RotorNet 的单跳路径发送，也允许通过多个双跳路径间接发送。这种多路径可能会导致在接收端无序交付。在接收端使用重新排序缓冲区可以确保有序交付 评估 问题由于直连等待时间较长，RotorNet采用了额外的分组交换机来保证鼠标流的及时交付，但这增加了部署复杂度，在高突发场景下性能较差。","link":"/2021/12/07/12.7RotorNet/"},{"title":"MPRDMA","text":"背景目前的RDMA仍然是单路径传输，一个RDMA连接只能沿着一个网络路径流动，容易出现故障，无法充分利用数据中心中丰富的并行路径。 MP-RDMA导致了三个挑战： 首先，多路径传输应该跟踪每条路径上的拥塞状态，这样它就可以执行感知拥塞的负载分配。然而，这些状态随发送路径的数量线性增长。这可能会导致相当大的内存开销，即使一个RDMA连接使用的路径数量有限。然而，在当前的RoCE设计中，这些额外状态的大小已经比一个连接的整个状态大50%。 多路径将会导致数据包无序到达接收端。接收端需要额外的元数据来判断一个数据包是否到达。如果使用位图结构，则位图的大小不好判断,如果我们使用较少的位，那么任何序列号超出位图范围的包都将被丢弃。这将大大降低性能，因为吞吐量实际上受到最慢路径的限制。一个核心设计挑战是，即使我们只能跟踪非常有限的乱序包，也要保持高性能。 接收机网卡没有足够的内存来缓冲无序的数据包，但必须在它们到达时将它们放到主机内存中。因此， 主机内存中的数据可能会无序更新。这可能会导致一个微妙的问题，因为一些现有的应用程序隐式地假设内存更新的顺序与操作发布的顺序相同。应该尽量减少每个RDMA连接的内存占用，以支持更多的片上内存连接。 工作内容Challenge 1. 如何在不知道每个路径状态的情况下实现拥塞感知流量分割 Solution 1. multipath ack-clocking背景介绍 通过在UDP报头中选择特定的源端口来控制数据包的传输路径，并让ECMP获取实际的传输路径，由于具有相同源端口的数据包会映射到相同的网络路径，所以我们使用UDP源端口来标识网络路径，称为虚拟路径VP。 （接收到的数据包的数据直接放在主机内存中。对于WRITE和READ操作，原始的RDMA报头已经将地址嵌入到每个数据包中，因此接收方可以相应地放置数据。但是对于SEND/RECV操作，需要额外的信息来确定数据内存放置地址。这个地址在相应的RECV WQE中。MP-RDMA在每个SEND数据包中嵌入消息序列号(MSN)，以帮助接收端确定正确的RECV WQE。此外，消息内PSN (iPSN)也作为地址偏移量携带在每个SEND数据包中，以便将特定数据包的数据放置在SEND消息中。） 设计机制通过基于每包ECN的拥塞控制和多路径ACK时钟机制。对所有路径维护一个窗口。初始窗口随机vp，在调整了窗口大小之后，如果允许发包，将沿着ack中携带的vp发送。 多路径流体模型： MP-RDMA可以平衡所有发送路径之间的ECN标记比，无论它们的rtt、容量和RED标记曲线如何。在所有等成本路径都具有相同容量和RED标记曲线的数据中心中，MP-RDMA可以在多条路径之间平衡负载 Challenge 2. 如何跟踪无序数据包 Solution 2. out-of-order aware path selectionMP-RDMA在接收端使用简单的位图数据结构来跟踪到达的数据包。 跟踪OOO数据包的数据结构： 数据包迟迟未到，不合理： 我们的无序感知路径选择算法的核心思想是主动修剪慢路径，只选择具有相似延迟的快速路径。 将网络OOO程度控制到可接受水平的机制： 路径不能一直减少，MP-RDMA定期探测新的路径，以找到更好的路径。具体来说，每个RTT，发送者向一个新的随机VP发送一个包，而不是ACK的VP。这个p平衡了充分利用当前一组良好路径和找到更好的路径的机会。实验中，设置p为1%。 Challenge 3. 如何在保序的同时通过多路实现性能增益 Solution 3. explicit sychronise operatio问题=》NIC硬件没有足够的内存来存储无序的数据包，必须将它们放到主机内存中。一种可能的方法是在主机内存中分配一个单独的重新排序缓冲区，并在那里临时存储无序的数据包。当完全接收到消息时，网卡可以将该消息从重新排序的缓冲区复制到正确的内存位置。然而，这导致重大开销。 解决=》直接将无序数据包的数据放入应用程序内存中 问题=》应用程序需要按顺序进行消息传递，内存中的数据可能无序更新 进程可以使用写操作来更新远程内存，然后发出另一个写操作来设置标志以通知远程进程。如果第二个写入在第一个写入之前更新内存，则远程进程可能会过早地读取部分数据并失败 解决=》同步消息接口。同步消息保证在所有以前的消息之后到达。延迟同步操作： 问题 cwnd增窗时，新发的数据包从哪条路径 与PFC共存时，无序数据包机制会在PFC恢复后杀死被暂停的路径","link":"/2021/11/09/11.9MPRDMA/"},{"title":"HPCC和On-Ramp奔跑指南","text":"HPCC和On-Ramp奔跑指南问题： 由于编译器的版本问题，这里不能使用 const 修饰符 去往/src/core/test/command-line-test-suite.cc ，删除两个 const 攻略编写网络仿真脚本：有了相应的模块，就可以搭建网络仿真环境，ns3仿真脚本支持两种语言：C++和Python，但是两种语言的API接口是一样的，部分API可能还没有提供Python接口。编写ns3仿真脚本的大体过程如下。 生成节点：ns3中节点相当于一个空的计算机外壳，接下来要给这个计算机安装网络所需要的软硬件，如网卡、应用程序、协议栈等。安装网络设备：不同的网络类型有不同的网络设备，从而提供不同的信道、物理层和MAC层，如CSMA、WiFi、WiMAX和point-to-point等。安装协议栈：ns3网络中一般是TCP/IP协议栈，依据网络选择具体协议栈，如是UDP还是TCP，选择何种不同的路由协议（OLSR、AODV和Global等）并为其配置相应的IP地址，ns3即支持IPv4也支持IPv6。安装应用层协议：依据选择的传输层协议选择相应的应用层协议，但有时需要自己编写应用层产生网络数据流量的代码。开始仿真。其中节点，网络设备，信道，应用程序的基本概念可以参照下面的这个文章 https://blog.csdn.net/weichanghu_/article/details/83306998 第四步 了解一下NS3的时间调度机制 https://blog.csdn.net/rustfree/article/details/84558058 第五步 NS3官网给了first.cc点对点，CSMA和wifi 的示例 通过这个示例你就可以了解大概的一个开发流程了 https://www.docin.com/p-2009136480.html 第六步 NS3 API 这个时候NS3的大概框架应该掌握的差不多了，那么就可以试着看下面的代码了，然后这个文档里会定义一些NS3的一些特殊类，可以到这里查找，以及一些模型，也可以在这里查找，值得注意是，这个API有些古老，有些特性已经变了，比如随机指数变量的使用。 https://www.nsnam.org/docs/release/3.7/doxygen/annotated.html","link":"/2021/12/12/HPCC%E5%92%8COn-Ramp%E5%A5%94%E8%B7%91%E6%8C%87%E5%8D%97/"},{"title":"终端主机的AQM","text":"背景主动队列管理（AQM）领域： 一个学派认为，瓶颈链路上的路由器知道缓冲区何时满了，因此处于判断拥塞开始的最佳位置。一旦检测到拥塞，它们通过二进制信号（例如，[2,14,16,19,25]）或非二进制信号（例如，[18,32]）隐式地通知终端主机，该信号通知发送方其发送速率应该是多少。 第二种学派讲网络视为黑匣子，试图从终端主机检测网络拥塞。在这些方案中，发送方试图根据往返时间或观察到的吞吐量中包含的信息来确定网络中的拥塞水平，并对其作出响应，以防止数据包丢失。在这种方法中，发送方不期望路由器提供任何支持将这方面的工作称为基于终端主机延迟的拥塞避免。 虽然路由器确实处于检测网络拥塞的最佳位置，但在核心路由器中部署实验性AQM机制并不容易。 但基于终端主机延迟的方案受到了对终端主机拥塞预测准确性和有效性的质疑。 通过在终端主机的拥塞响应函数中模拟基于路由器的AQM方案的概率标记机制，可以获得类似于基于路由器的AQM的性能和效益，而不需要对路由器进行任何修改 基于终端主机的拥塞预测的相关工作 在TRI-S[29]中，作者建议使用归一化吞吐量梯度而不是归一化延迟梯度来预测瓶颈链路何时达到饱和。 在DUAL[30]中，作者将RTT的当前样本与最小和最大RTT的平均值进行比较，以确定瓶颈链路队列是否已满了一半，是否需要响应。 在Vegas[7]中，作者建议将实现的吞吐量与基于最小观测RTT的预期吞吐量进行比较，以预测拥塞。 在CIM[21]中，作者建议将少量RTT样本的移动平均值与大量RTT样本的移动平均值进行比较，以确定是否存在拥塞。 在TCP-BFA[3]中，作者建议监控RTT的变化，以防止瓶颈链路填满。 在Sync-TCP[31]中，作者使用单向延迟趋势结合四种不同级别的窗口增加/减少来改进基于延迟的拥塞避免 状态A表示“低延迟”或“低拥塞”状态。当观察到更高的延迟或瓶颈队列开始被填满时，流从状态A转换为状态B。如果未采取任何操作，则流将转换为状态C或“数据包丢失”状态。作为对数据包丢失的响应，当流减少其拥塞窗口时，瓶颈队列开始清空，流最终将返回到状态A。 过渡“4”（状态A到C）可能意味着发生了短期拥塞，并且流无法预测它，因此无法避免由此产生的损失，或者协议在预测拥塞方面不够积极。这种转变表明存在“假阴性”（false negatives）。 另一方面，我们称之为“假阳性”（false positive）的转换“5”（状态B到A）将意味着协议在预测拥塞时过于激进或不可靠，因此可能会不必要地降低其发送速率并面临性能下降。 设计机制RED协议栈的路由器中，通过监测平均队列长度来推断拥塞，同时通过允许瞬时队列长度的波动来适应突发流量。 概率早期响应TCP（PERT）解决假阳性，当假阳性概率较高时，对早期拥塞信号的响应概率应较低，反之亦然。 设置两个阈值Tmin和Tmax,以及响应的最大概率Pmax。如果srtt0.99的值小于Tmin，响应概率就为0.当srtt0.99增长到超过Tmin，响应于每个ACK而减小窗口的概率线性增加。 当srtt0.99介于Tmax和2Tmax之间，概率从Pmax变为1，超过Pmax,概率保持不变为1。 对于参数Tmin、Tmax和Pmax，分别使用固定值（p+5ms、p+10ms和0.05），p是从流中基于最小RTT观察到的传播延迟。 PERT模型由三部分组成：窗口调整、RED仿真和排队延迟计算 窗口调整：R（t）表示终端用户在时间t测量的往返时间，传播延迟Tp和排队延迟Tq 用C表示链路的容量，用q（t）表示t时刻的队列大小，排队延迟Tq（t）可以近似为q（t−R（t））/C p(t)为数据包丢失概率： RED仿真的一个组成部分是对往返时间R（t）的估计，该时间R（t）使用权重为α的低通滤波器（LPF）对每个分组进行更新： 根据LPF的微分方程进行描述： 计算排队延迟： 核心思想通过在终端主机的拥塞响应函数中模拟基于路由器的AQM方案的概率标记机制，可以获得类似于基于路由器的AQM的性能和效益，而不需要对路由器进行任何修改。","link":"/2021/11/29/11.29%E7%BB%88%E7%AB%AF%E4%B8%BB%E6%9C%BA%E7%9A%84AQM/"},{"title":"ns3.17环境的搭建与奔跑","text":"ubuntu16.04.7 安装 下载 创建 安装 VMware Tools ns3 3.17 安装与运行 切换 python 版本 安装依赖 安装 ns3 3.17 简单测试 安装可视化界面 ubuntu16.04.7 安装下载统一使用Ubuntu16.04 （ns3、ns2、DPDK）Ubuntu 16.04.7 LTS (Xenial Xerus) 创建新建虚拟机 选择 workstation 16.x 稍后安装操作系统 够用 虚拟机统一选择创建虚拟磁盘，方便转移 选择编辑此虚拟机，使用刚刚下载的镜像 安装 最小安装即可 虚拟磁盘无所谓 选定时区 等待 VMware Tools双击 etc\\apt\\sources.list ,将apt换成国内的源，比如中科大。 Crtl +Alt + T 打开终端 执行 以下命令进行更新 12sudo apt-get upgradesudo qpt-get update 安装 tools , 重启生效 12sudo apt-get install open-vm-tools-desktop -ysudo reboot ns3 3.17 安装与运行下载地址 https://www.nsnam.org/releases/ns-allinone-3.17.tar.bz2 切换 python 版本说明一点，支持 n3 3.17 的 python 版本是 python 2.x , 而支持 DPDK 20.11 依赖需要 python 3.7+ ,而 Ubuntu 16.04 默认的 python 版本是 2.7.12 ，所以目前不用动。 如有需要，按以下方式切换版本。 123456#查看python版本python --version#列出python版本update-alternatives --list python#切换python版本update-alternatives --config python 安装依赖首先安装 gcc 编译器 1sudo apt-get install gcc g++ python python-dev 下面一个一个来，这一步要安装好，不然后面查缺补漏很难受 1234567891011121314151617181920sudo apt-get install mercurial sudo apt-get install bzr sudo apt-get install gdb valgrind sudo apt-get install gsl-bin libgsl0-dev libgsl2sudo apt-get install flex bison libfl-dev sudo apt-get install tcpdump sudo apt-get install sqlite sqlite3 libsqlite3-dev sudo apt-get install libxml2 libxml2-dev sudo apt-get install libgtk2.0-0 libgtk2.0-dev sudo apt-get install vtun lxc sudo apt-get install uncrustify sudo apt-get install doxygen graphviz imagemagick sudo apt-get install texlive texlive-latex-extra texlive-generic-extra texlive-generic-recommendedsudo apt-get install texinfo dia texlive texlive-latex-extra texlive-extra-utils texlive-generic-recommended texi2html sudo apt-get install python-sphinx dia sudo apt-get install python-pygraphviz python-kiwisudo apt-get install qt4-qmake sudo apt-get install qt4-dev-tools sudo apt-get install libboost-signals-dev libboost-filesystem-devsudo apt-get install openmpi-bin openmpi-doc libopenmpi-dev 最后一个搞定 安装 ns3 3.17Crtl +Alt + T 打开终端 方便操作，我这里选择在桌面进行安装 12cd Desktopwget http://www.nsnam.org/release/ns-allinone-3.17.tar.bz2 下载完成后，我们进行解压 使用下面的命令 1tar -xjvf ns-allinone-3.17.tar.bz2 进入文件夹，进行安装 123cd ns-allinone-3.17 #安装方式有三种，具体可去官网查看sudo ./build.py 等待编译，编译完成后得到如下界面：（报错哈哈哈，问题是 TX 是个值为3的常量，但等式前面是一个bool常量，所以不能相等） solution : 前往 /src/uan/model/uan-mac-cw.cc 修改代码,也可以直接覆盖 1234567891011121314151617181920switch (m_state) { case CCABUSY: NS_LOG_DEBUG (&quot;Time &quot; &lt;&lt; Simulator::Now ().GetSeconds () &lt;&lt; &quot; MAC &quot; &lt;&lt; GetAddress () &lt;&lt; &quot; Starting enqueue CCABUSY&quot;); // Add the following section int temp_flag; temp_flag = TX &gt; 0 ? 1 : 0; //Modify the TX to temp_flag if (m_txEndEvent.IsRunning () == temp_flag) { NS_LOG_DEBUG (&quot;State is TX&quot;); } else { NS_LOG_DEBUG (&quot;State is not TX&quot;); } NS_ASSERT (m_phy-&gt;GetTransducer ()-&gt;GetArrivalList ().size () &gt;= 1 || m_phy-&gt;IsStateTx ()); return false; 安装成功后会显示如下的界面： 简单测试ns3.17 自带的 helloworld 12cd ns-3.17 sudo ./waf --run hello-simulator 报错（编译器问题，默认没编译测试程序） 解决方法： 123456789cd ns-3.17 # 清除waf编译器的缓存sudo ./waf clean# 修改waf的配置为 debug ,重新配置ns3，优化编译包括例子和测试，默认情况下例子和测试是不编译的，然后系统会重新配置，编译系统会检查ns3依赖的软件包是否安装成功sudo ./waf -d debug --enable-example --enable-tests configure # 重新启动 waf，等待编译完成sudo ./waf # 重新启动 示例 程序sudo ./waf --run hello-simulator 完成 安装可视化界面安装相关依赖 12sudo apt-get install libgoocanvas-devsudo apt-get install python-pygraphviz python-kiwi python-pygoocanvas 使用build.py进行编译 1sudo ./build.py --enable-examples --enable-tests 重新构建waf 1234cd ns-3.17sudo ./waf clean //清除以前的版本sudo ./waf -d debug --enable-examples --enable-tests configure //重新配置ns-3项目，并构建系统检查各种依赖关系sudo ./waf //进行waf编译 安装PyViz 12sudo apt-get install python-dev python-pygraphviz python-kiwi python-pygoocanvas python-gnome2 gir1.2-goocanvas-2.0 python-rsvgsudo apt-get install ipython 运行程序时加入参数 -vis; 使用命令进行测试 1sudo ./waf --run src/olsr/examples/simple-point-to-point-olsr --vis //在ns-3.17目录下 简单说明，单击Simulate仿真按钮开始仿真，在仿真过程中出现的绿色代表通信状态。","link":"/2021/12/11/ns3.17%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"拥塞控制","slug":"拥塞控制","link":"/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"},{"name":"单向延迟","slug":"单向延迟","link":"/tags/%E5%8D%95%E5%90%91%E5%BB%B6%E8%BF%9F/"},{"name":"突发流","slug":"突发流","link":"/tags/%E7%AA%81%E5%8F%91%E6%B5%81/"},{"name":"队列长度","slug":"队列长度","link":"/tags/%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6/"},{"name":"斜率","slug":"斜率","link":"/tags/%E6%96%9C%E7%8E%87/"},{"name":"单项延迟","slug":"单项延迟","link":"/tags/%E5%8D%95%E9%A1%B9%E5%BB%B6%E8%BF%9F/"},{"name":"光电交换机","slug":"光电交换机","link":"/tags/%E5%85%89%E7%94%B5%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"多路径","slug":"多路径","link":"/tags/%E5%A4%9A%E8%B7%AF%E5%BE%84/"},{"name":"概率响应","slug":"概率响应","link":"/tags/%E6%A6%82%E7%8E%87%E5%93%8D%E5%BA%94/"}],"categories":[{"name":"拥塞控制","slug":"拥塞控制","link":"/categories/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"},{"name":"光电交换机","slug":"光电交换机","link":"/categories/%E5%85%89%E7%94%B5%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"ns3实验","slug":"ns3实验","link":"/categories/ns3%E5%AE%9E%E9%AA%8C/"},{"name":"突发流","slug":"拥塞控制/突发流","link":"/categories/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E7%AA%81%E5%8F%91%E6%B5%81/"},{"name":"广域网","slug":"拥塞控制/广域网","link":"/categories/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E5%B9%BF%E5%9F%9F%E7%BD%91/"}]}